## 一、背景与需求分析

随着业务的不断发展，单库单表往往面临以下挑战：

- **数据量激增**：单表数据量达到千万甚至亿级后，SQL查询和索引更新都会明显变慢。
- **并发瓶颈**：单个数据库实例对并发写入和查询的支撑能力有限，容易成为系统性能的瓶颈。
- **维护风险**：备份、DDL修改、数据迁移等操作在单库数据量过大时存在较大风险。

因此，分库分表设计的核心目标是**水平扩展数据库性能**，同时保证数据访问的高效性和系统的稳定性。

## 二、设计原则

在设计分库分表方案时，需要遵循以下基本原则：

1. **按需分库分表**  
   尽量在其它手段（如读写分离、索引优化、硬件升级）无法满足需求时再进行分库分表，遵循“能不分就不分”的原则。

2. **数据分布均匀**  
   选择合适的分片键（如订单ID、用户ID等），采用 Hash 取模、范围分片或组合策略，确保数据在各个库和表间均衡分布，避免热点问题。

3. **业务隔离**  
   根据业务类型进行垂直拆分，将不同业务模块（例如订单、用户、日志等）拆分到不同的库中，既降低单库压力，又能提高系统容错性。

4. **扩展性与灵活性**  
   采用 2 的 N 次幂作为分库分表数量，便于使用位运算（如 `id & (N-1)`) 进行路由，同时便于后期的平滑扩容或缩容。

5. **数据一致性保障**  
   考虑双写、数据校验与订正方案，解决在数据迁移、扩容过程中可能出现的同步和一致性问题。

## 三、分库分表策略

### 1. 垂直拆分
- **概念**：根据业务模块将表分到不同的数据库实例中，例如将订单、用户、日志分别存储于不同库中。
- **优点**：业务耦合低，管理上更清晰；避免了不同业务相互影响。
- **注意**：跨业务查询需要额外设计，如全局表或数据冗余。

### 2. 水平拆分
- **概念**：针对单表数据量过大，将数据按某一维度（如订单ID、用户ID或时间）拆分到多个子表中。
- **常用策略**：
    - **Hash 切分**：如采用 `order_id % (分库数 × 分表数)` 的算法确定数据所在库和表。
    - **范围切分**：根据时间或ID范围划分数据段。

## 四、设计方案示例

### 1. 选择分片键
- **分片键要求**：唯一性、查询频繁且与业务密切相关。
- **示例**：订单系统中通常采用 `order_id` 或 `user_id` 作为分片键。

### 2. 路由算法设计
- **算法示例**：
    - 假设系统设计为：2个分库，每库4张表，总共8张表。
    - 路由规则：
        - **库分配**：`库索引 = order_id % 8 / 4`
        - **表分配**：`表索引 = order_id % 4`
    - 例如，`order_id = 15` 则：
        - `15 % 8 = 7`，库索引 = `7 / 4 = 1`（第2个库），表索引 = `7 % 4 = 3`（第4张表）。

### 3. 分布式ID 方案
- **需求**：避免各库、各表中主键重复。
- **常见做法**：采用雪花算法（Snowflake）生成全局唯一的ID。

### 4. 数据迁移与双写策略
- **双写方案**：在分库分表实施初期，应用同时写入老系统和新系统，新旧数据通过异步数据校验、全量和增量比对实现数据一致性。
- **数据迁移**：分批次全量迁移历史数据，并配合定时任务做增量数据校验和补齐。

### 5. 中间件选择
- **推荐**：ShardingSphere、MyCat 等，前者作为 client 层方案耦合度较高但无需额外部署，后者作为 proxy 层方案解耦更好。

## 五、扩展性与容错设计

- **扩容策略**
    - 采用 2 的 N 次幂的分表数量（如 32、64、128 等），便于后续使用位运算实现高效路由，也便于通过增加库或表平滑扩容。
    - 扩容时可利用“平滑扩/缩容”方案，通过双倍扩容策略减少数据迁移量。

- **容错与跨库查询问题**
    - 避免跨库join：尽量通过提前冗余数据或全局表来解决跨库查询问题。
    - 分布式事务：尽量将相关业务数据存放在同一分片内，避免分布式事务；若必须使用，可采用柔性事务或 TCC 模式处理。

## 六、总体架构图示意

```
                ┌────────────────────────────┐
                │        应用服务器           │
                └─────────────┬──────────────┘
                              │
                       ┌──────▼──────┐
                       │ 分库分表中间件 │   ←（如 ShardingSphere）
                       └──────┬──────┘
                              │
         ┌────────────────────┼────────────────────┐
         │                    │                    │
  ┌──────▼─────┐       ┌──────▼─────┐       ┌──────▼─────┐
  │   库 A     │       │   库 B     │  ...  │   库 N     │
  │ ┌───────┐  │       │ ┌───────┐  │       │ ┌───────┐  │
  │ │表A0~A(m)│  │       │ │表B0~B(m)│  │       │ │表N0~N(m)│  │
  │ └───────┘  │       │ └───────┘  │       │ └───────┘  │
  └────────────┘       └────────────┘       └────────────┘
```

## 七、总结

- **优势**：
    - 显著降低单表数据量，提高 SQL 执行效率；
    - 分散并发压力，提升整体系统吞吐量；
    - 便于后期水平扩展。

- **挑战**：
    - 跨库、跨表的复杂查询和聚合问题；
    - 数据迁移、双写与一致性校验的实现复杂度；
    - 分布式事务和全局唯一ID的生成问题。

在实际应用中，应根据业务特点选择合适的分库分表方案，并配合中间件、监控、数据迁移工具等保障系统的高可用性和稳定性。

